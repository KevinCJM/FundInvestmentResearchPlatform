# 大类资产配置权重复用优化任务拆解

## 背景
- 当前前端在发起回测前，会再次逐个策略调用 `/api/strategy/compute-weights` 以更新展示权重。
- 对于启用“再平衡 + 动态重算”的风险预算 / 指定目标策略，前端之前已经调用 `/api/strategy/compute-schedule-weights` 获取了全部调仓日权重；回测引擎亦会在运行时根据相同窗口重复求解。
- 结果是相同的模型求解在调仓流程中被执行了多次，影响响应延迟。

## 目标
- 让动态再平衡策略在调仓表和回测之间共享一次求得的权重序列，避免重复调用模型求解函数。
- 保证前后端请求格式稳定，回测结果与旧逻辑保持一致。
- 在回归测试中覆盖缓存复用与基线结果一致性。

## 任务拆解
1. **缓存设计与接口约定**
   - 梳理 schedule 请求体组成元素，定义稳定的指纹（fingerprint）。
   - 在 `/api/strategy/compute-schedule-weights` 返回 `cache_key`，并在服务端持久化到轻量缓存（LRU）。
   - 回测请求支持携带 `precomputed` 指纹，后端命中缓存时直接返回相同的调仓权重序列。

2. **前端串联缓存**
   - 统一封装风险预算 / 指定目标策略的求权重请求体生成逻辑。
   - 在发起回测前确认所需的调仓权重缓存是否存在；若缺失则自动触发 schedule 接口填充缓存。
   - 回测请求体中附带 `precomputed` 指纹，并用缓存返回的最新一列权重更新展示。
   - 移除冗余的 `/api/strategy/compute-weights` 调用，避免重复求解。

3. **回测引擎复用预计算权重**
   - 在 `_static_or_rebalanced` 中注入 `precomputed_weights` 查找逻辑；命中时跳过 `_compute_model_weights`。
   - 保持资产顺序校验，确保缓存内容与当前资产列一致。

4. **测试与验证**
   - 后端增加用例，校验缓存命中时不会触发模型函数，并验证预计算与即时计算的结果一致。
   - 前端执行 `npm run build` 确认编译通过。
   - 后端运行 `pytest backend/tests/test_strategy_api.py`，验证回归用例通过。

